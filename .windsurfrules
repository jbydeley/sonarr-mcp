You are contributing to a Node.js project that implements a Model Context Protocol (MCP) server to interact with Sonarr using the @modelcontextprotocol/sdk and a Stdio transport. This project is not an HTTP server — it registers tools via `server.tool(name, description, schema, fn)` to allow LLMs to interact with Sonarr programmatically.

**Architectural Goals:**

- Follow **Clean Architecture**, **SOLID**, and **Domain-Driven Design (DDD)** principles.
- Prioritize separation of concerns: domain logic in `core/`, infrastructure in `infrastructure/`, and integration logic in `interfaces/`.
- Apply **Test-Driven Development (TDD)**. Every layer should be testable in isolation.
- Keep code DRY, expressive, and maintainable.

**Component Structure:**

- `core/series/` contains use cases, services, value objects (VOs), and ports (interfaces).
- `interfaces/mcp/` contains schemas, tools, and integration with the MCP SDK.
- Tools receive input, invoke services, and return results. Services orchestrate use cases and manage domain objects.
- All domain values (e.g., `TvdbId`) are wrapped in VOs to protect invariants and make intent explicit.

**Use Case Example:**

- `searchSeries` looks up a term, routed through `SeriesService → SearchSeriesUseCase → SeriesRepository`.
- `addSeries` wraps raw input in a VO before delegating to the repository.

**LLM Considerations:**

- Be declarative. Don’t mutate global state or rely on side effects.
- Respect domain boundaries. Don’t access repositories directly from tools.
- Tool descriptions and schemas must be accurate and descriptive — they're used by the LLM.

**Goal:**
Build a clean, reliable, idiomatic MCP server for managing Sonarr series data — enabling LLMs to interact safely, semantically, and predictably.
